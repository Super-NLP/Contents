---
description: 전통적인 언어모델에 대해 알아봅시다.
---

# 👾 Language Model

언어 모델(Language Model, LM)은 "언어라는 현상을 모델링"하고자 단어 시퀀스(문장)에 확률을 할당(assign)하는 인공지능 모델입니다. 언어 모델을 만드는 방법은 크게는 **통계를 이용한 방법(=Statical LM, SLM)**과 **인공 신경망을 이용한 방법(= Language Model, LM)**으로 구분할 수 있습니다. 최근에는 통계를 이용한 방법보다는 인공 신경망을 이용한 방법이 더 좋은 성능을 보여주고 있습니다. Transformer부터 시작해서 GPT나 BERT 또한 인공 신경망 언어 모델의 개념을 사용하여 만들어졌습니다. 언어모델에 대한 전체적인 카테고리를 파악하고 내용을 다뤄봅시다.

언어 모델은 기본적으로 **단어 시퀀스에 확률을 할당(assign)** 하는 일을 합니다. 즉, 가장 자연스러운 단어 시퀀스를 찾아내는 일이라고 할 수 있습니다. 단어 시퀀스에 확률을 할당하게 하기 위해서 가장 보편적으로 사용되는 방법은 언어 모델이 **이전 단어들이 주어졌을 때 다음 단어를 예측**하도록 하는 것입니다.

다른 유형의 언어 모델로는 주어진 양쪽의 단어들로부터 가운데 비어있는 단어를 예측하는 언어 모델이 있습니다. 이는 문장의 가운데에 있는 단어를 비워놓고 양쪽의 문맥을 통해서 빈 칸의 단어인지 맞추는 고등학교 수험 시험의 빈칸 추론 문제와 비슷합니다. 이러한 유형은 Masking 기반의 언어모델이라고 하는데 BERT를 다룰때 자세히 알아보겠습니다.

**언어 모델링(Language Modeling)**은 주어진 단어들로부터 아직 모르는 단어를 예측하는 작업을 말합니다.&#x20;

자연어 처리로 유명한 스탠포드 대학교에서는 언어 모델을 문법(grammar)이라고 비유하기도 합니다. 언어 모델이 단어들의 조합이 얼마나 적절한지, 또는 해당 문장이 얼마나 적합한지를 알려주는 일을 하는 것이 마치 문법이 하는 일 같기 때문입니다.

## Ⅰ. SLM : Statical LM

### ⅰ. 조건부확률과 SLM

일반적으로 통계적 언어모델은 조건부확률(Conditional Probability)을 기반으로 합니다. 조건부 확률은 두 확률 $$P(A), P(B)$$에 대해서 아래와 같은 관계를 갖습니다.

$$
P(B|A) = P(A,B) / P(A)\\P(A,B) = P(A)P(B|A)
$$

여기서 $$P(B|A)$$를 사건 A가 일어났을 때 B가 일어날 확률을 말하게 되는데 위 수식을 일반화시키면 아래와 같이 표현할 수 있습니다.

$$
P(x_1,x_2,x_3,\cdots,x_n) = P(x_1)P(x_2|x_1)P(x_3|x_1,x_2)\cdots P(x_n | x_1 \cdots x_n)
$$

이와 같이 표현하는 원리를 조건부확률의 **연쇄법칙(chain rule)**을 따랐다고 합니다. 이것을 문장에 접목시켜 보면 **각 단어는 문맥이라는 관계로 인해 이전 단어의 영향을 받아 나온 단어**입니다. 그리고 모든 단어로부터 하나의 문장이 완성됩니다. 그렇기 때문에 문장의 확률을 구하고자 조건부 확률을 사용하겠습니다. 앞서 언급한 조건부 확률의 일반화 식을 문장의 확률 관점에서 다시 적어보면 문장의 확률은 각 단어들이 이전 단어가 주어졌을 때 다음 단어로 등장할 확률의 곱으로 구성됩니다. 즉 아래와 같이 표현할 수 있는것 입니다.

$$
P(w_1,w_2,\cdots , w_n) = \prod_{n=1}^n P(w_n | w_1, w_2, \cdots , w_n-1)
$$

결국, 문장의 확률을 구하기 위해서 다음 단어에 대한 예측 확률을 모두 곱한다는 것입니다. 여기서 SLM은 카운트에 기반하여 이전 단어로부터 다음 단어에 대한 확률을 계산합니다. 여전히 SLM은 단어의 출현 빈도수를 기반으로 하여 언어 모델링을 하기때문에 정말 방대한 Corpus의 양을 필요로 합니다. 그러나 이론과 적용은 다르듯 실제로 우리가 통계적 언어모델링을 할때 충분한 데이터를 모으지 못해 현실에서는 잘 사용하는 언어를 정확히 모델링하지 못하는 문제가 발생하곤 하는데 이것을 **희소 문제(sparsity problem)**라고 합니다.

이러한 희소 문제를 해결하기 위한 대표적인 방법이 바로 n-gram 언어 모델들입니다.

### ⅱ. N-Gram Model

n-gram 언어 모델은 앞서 언급한 언어 모델과는 달리 일부 단어만 고려하는 접근 방법을 사용합니다. 그리고 이때 일부 단어를 몇 개 보느냐를 결정하는데 이것이 n-gram에서의 n이 가지는 의미입니다. SLM의 한계는 훈련 코퍼스에 확률을 계산하고 싶은 문장이나 단어가 없을 수 있다는 점인데 단어의 확률을 구하고자 기준 단어의 앞 단어를 전부 포함해서 카운트하는 것이 아니라, 앞 단어 중 임의의 개수만 포함해서 카운트하여 근사하는 방식으로 접근하자는 것이 n-gram의 중요포인트입니다. 이렇게 하면 갖고 있는 코퍼스에서 해당 단어의 시퀀스를 카운트할 확률이 높아질 것입니다.

n-gram은 n개의 연속적인 단어 나열을 의미합니다. 코퍼스에서 n개의 단어 뭉치 단위로 끊어서 이를 하나의 토큰으로 간주합니다. 종류는 다음과 같습니다.

👉 예시 문장 : An adorable little boy is spreading smiles

* **uni**grams : an, adorable, little, boy, is, spreading, smiles
* **bi**grams : an adorable, adorable little, little boy, boy is, is spreading, spreading smiles
* **tri**grams : an adorable little, adorable little boy, little boy is, boy is spreading, is spreading smiles
* **4**-grams : an adorable little boy, adorable little boy is, little boy is spreading, boy is spreading smiles

n-gram을 통한 언어 모델에서는 다음에 나올 단어의 예측은 오직 n-1개의 단어에만 의존합니다. 예를 들어 **'An adorable little boy is spreading'** 다음에 나올 단어를 예측하고 싶다고 할 때, n=4라고 한 4-gram을 이용한 언어 모델을 사용한다고 합시다. 이 경우, spreading 다음에 올 단어를 예측하는 것은 n-1에 해당되는 앞의 3개의 단어만을 고려합니다.

<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

이러한 방식에도 한계점이 분명 존재하는데 다음과 같습니다.

*   #### 희소 문제(Sparsity Problem) <a href="#id-1-sparsity-problem" id="id-1-sparsity-problem"></a>

    문장에 존재하는 앞에 나온 단어를 모두 보는 것보다 일부 단어만을 보는 것으로 현실적으로 코퍼스에서 카운트 할 수 있는 확률을 높일 수는 있었지만, n-gram 언어 모델도 여전히 n-gram에 대한 희소 문제가 존재합니다.
*   #### n을 선택하는 것은 trade-off 문제. <a href="#id-2-n-trade-off" id="id-2-n-trade-off"></a>

    n을 크게 선택하면 실제 훈련 코퍼스에서 해당 n-gram을 카운트할 수 있는 확률은 적어지므로 희소 문제는 점점 심각해지며 동시에 모델 사이즈가 커진다는 문제점이 있습니다. 반대로 n을 작게 선택하면 훈련 코퍼스에서 카운트는 잘 되겠지만 근사의 정확도는 현실의 확률분포와 멀어집니다. 그렇기 때문에 적절한 n을 선택해야 합니다. 앞서 언급한 trade-off 문제로 인해 정확도를 높이려면 **n은 최대 5를 넘게 잡아서는 안 된다고 권장**되고 있습니다.

이러한 한계점들에 대한 해결이 되지않아 등장한 것이 **신경망을 기반으로 한 언어모델**입니다.

## Ⅱ. LM

앞서 배운 Word2Vec부터는 신경망을 이용한 방식입니다. 즉, 자연어처리의 분야는 통계적 기법에서 인공신경망을 이용하는 흐름을 가지고 있으며 앞으로 공부할 모델들은 모두 신경망 기반의 모델입니다. 물론 그 구조와 장/단점은 모델마다 다르고 내용이 방대하니 따로 정리하도록 하겠습니다.

